# Отчет

## 1

Компиляция: 
```bash
gcc -o program 1.c -lpthread -lm
```
Запуск 
```bash
./program nthreads ntrials
```

### Задача

Необходимо определить значение числа π с помощью метода Монте-Карло. В данном методе моделируется случайное бросание точек в квадрат со стороной 2r. Внутри квадрата рисуется вписанная окружность радиусом r. Отношение количества попаданий точек в окружность к общему количеству бросков приближенно равно π/4. Таким образом, значение числа π можно выразить формулой:

![Формула 1](https://latex.codecogs.com/png.latex?%5Cpi%20%5Capprox%204%20%5Ctimes%20%5Cfrac%7BN%7D%7BT%7D)

Где N — количество попаданий в окружность, а Т — общее количество бросков.

### Описание алгоритма

1. Программа делит общее количество бросков на равные части, распределяя их между несколькими потоками.
2. Каждый поток выполняет свои броски, генерируя случайные координаты точек (x, y) в пределах квадрата со стороной 2. Точка считается попавшей в окружность, если выполнено условие ![Формула 2](https://latex.codecogs.com/png.latex?x%5E2%20%2B%20y%5E2%20%5Cleq%201).
3. Результаты всех потоков суммируются, чтобы определить общее количество попаданий в окружность.
4. Значение π оценивается по формуле![Формула 1](https://latex.codecogs.com/png.latex?%5Cpi%20%5Capprox%204%20%5Ctimes%20%5Cfrac%7BN%7D%7BT%7D).
5. Для измерения времени выполнения используется функция `clock()` из библиотеки `<time.h>`, которая позволяет определить время начала и конца работы программы, а затем вычислить разницу между ними в секундах.

### Результаты

| Количество потоков | Количество попыток | Число π   | Время выполнения (сек) |
|---------------------|--------------------|-----------|-------------------------|
| 1                   | 1000               | 3.120000  | 0.000088                |
| 2                   | 1000               | 3.140000  | 0.000111                |
| 4                   | 1000               | 3.116000  | 0.000192                |
| 8                   | 1000               | 3.124000  | 0.000405                |
| 1                   | 1                  | 4.000000  | 0.000071                |
| 1                   | 2                  | 2.000000  | 0.000066                |
| 1                   | 4                  | 4.000000  | 0.000078                |
| 1                   | 8                  | 3.000000  | 0.000075                |
| 1                   | 16                 | 2.500000  | 0.000072                |
| 1                   | 10000000           | 3.141303  | 0.122424                |
| 10000               | 10000              | 3.126400  | 0.408544                |
| 10000               | 100000             | 3.140440  | 0.404356                |
| 10000               | 1000000            | 3.140984  | 0.404244                |
| 10000               | 10000000           | 3.142326  | 0.421584                |

### Анализ результатов
   - Увеличение числа потоков (от 1 до 8) при фиксированном количестве попыток (1000) не дает значительного улучшения в точности оценки числа π. Значения колеблются вокруг 3.12 и 3.14, что указывает на высокую степень случайности в результатах.
   - Увеличение количества попыток при использовании одного потока (с 1 до 10000000) приводит к более стабильным значениям числа π. Например, при 10000000 попытках значение π составляет 3.141303, что ближе к истинному значению (≈ 3.14159).
   - При увеличении количества попыток время выполнения программы также увеличивается, что ожидаемо, так как требуется больше вычислений.
   - Также можно заметить, что при маленьком числе попыток увеличение количества потоков увеличивает время, что свидетельствует о том, что взаимодействие с потоками занимает больше времени, чем вычисления

### Ускорение и эффективность
Ускорение рассчитывается по формуле: S(p)= T(1)/T(p), где T(1) — время выполнения программы на одном потоке, T(p) — время выполнения программы на p потоках. Эффективность показывает, насколько эффективно используются потоки: E(p)= S(p)/p

| Количество потоков | Количество попыток | Время   | Ускорение | Эффективность |
|---------------------|--------------------|-----------|-----------|-----------|
| 1                   | 1000000            | 0.004115  | -         |1          |
| 2                   | 1000000            | 0.002300  | 1.8       |0.9          |
| 3                   | 1000000            | 0.001901  | 2.2       |0.7          |
| 4                   | 1000000            | 0.001035  | 4.0       |1          |
| 5                   | 1000000            | 0.000839  | 4.9       |0.9         |

### Выводы

- Метод Монте-Карло является эффективным для оценки числа π, но результаты зависят от количества попыток и используемых потоков.
- Для достижения более точного значения π желательно использовать большее количество попыток.
- Важно учитывать, что для малых количеств попыток оценки могут значительно варьироваться, что приводит к менее надежным результатам.
- При большом числе попыток (соответсвенно и вычислений), увеличение числа потоков приводит к ускорению программы, но результаты нестабильны

## 2

Компиляция: 
```bash
gcc -o program 2.c -lpthread -lm
```
Запуск 
```bash
./program nthreads ntrials
```

### Задача

Множество Мандельброта — это совокупность всех комплексных чисел ( c ), для которых последовательность 

![Формула 1](https://latex.codecogs.com/png.latex?z_%7Bn%2B1%7D%20%3D%20z_n%5E2%20%2B%20c)

является ограниченной для всех значений \( n \). Начальное значение \( z_1 = 0 \). Число \( c \) принадлежит множеству Мандельброта, если существует константа \( A \), такая, что для всех \( n \) выполняется 

![Формула 2](https://latex.codecogs.com/png.latex?%7Cz_n%7C%20%3C%20A).

Для практических целей значение \( A \) можно взять равным 2, т.е. число \( c \) принадлежит множеству Мандельброта тогда и только тогда, когда 

![Формула 3](https://latex.codecogs.com/png.latex?%7Cz_n%7C%20%3C%202)

для всех \( n \), пока не достигнуто максимальное количество итераций.

### Описание алгоритма

1. Программа делит область комплексной плоскости на равные части, распределяя вычисления между несколькими потоками. Каждый поток обрабатывает определенное количество точек на плоскости.

2. Для каждой точки \( c \), соответствующей координатам \( (x, y) \), программа вычисляет последовательность значений \( z \), используя формулу:

   ![Формула 1](https://latex.codecogs.com/png.latex?z_%7Bn%2B1%7D%20%3D%20z_n%5E2%20%2B%20c),

   начиная с \( z_1 = 0 \).

3. На каждом шаге проверяется, не превышает ли модуль \( |z_n| \) значение 2. Если модуль становится больше 2, точка не принадлежит множеству Мандельброта, и вычисления для этой точки прекращаются.

4. Если после максимального количества итераций модуль \( |z_n| \) остается меньше 2, точка считается принадлежащей множеству Мандельброта.

5. Результаты всех потоков записываются в CSV-файл, содержащий координаты точек, принадлежащих множеству.

6. Для повышения производительности используется многопоточность, при этом каждая точка обрабатывается независимо от других, что позволяет параллелизовать вычисления.

   ### Результаты

   | Количество потоков | Количество точек | Время выполнения (сек) |
   |---------------------|------------------|------------------------|
   | 1                   | 1000             | 1.741982               |
   | 2                   | 1000             | 1.764944               |
   | 3                   | 1000             | 1.849410               |
   | 4                   | 1000             | 1.983677               |
   | 5                   | 1000             | 2.104231               |
   | 1                   | 2000             | 7.429482               |
   | 2                   | 2000             | 8.011730               |
   | 3                   | 2000             | 8.519011               |
   | 4                   | 2000             | 8.411285               |
   | 5                   | 2000             | 9.362711               |

   ### Анализ результатов
   - При большом количестве точек время выполнения увеличивается с количеством потоков. Предположительо - из-за тяжелой операции записи в файл (а массив большого размера не создаётся).
   - На 500 точках заметно незначительное ускорение

### Ускорение и эффективность
Ускорение рассчитывается по формуле: S(p)= T(1)/T(p), где T(1) — время выполнения программы на одном потоке, T(p) — время выполнения программы на p потоках. Эффективность показывает, насколько эффективно используются потоки: E(p)= S(p)/p

| Количество потоков | Количество точек | Время   | Ускорение | Эффективность |
|---------------------|--------------------|-----------|-----------|-----------|
| 1                   | 500                | 0.516483  | -         |1          |
| 2                   | 500                | 0.428224  | 1.20      |0.6        |
| 3                   | 500                | 0.439673  | 1.17      |0.4        |
| 4                   | 500                | 0.433843  | 1.19      |0.3        |
| 5                   | 500                | 0.456054  | 1.13      |0.2        |

### Выводы
- Использование многопоточности не даёт ощутимой выгоды при маленьком числе точек и совсем неэффективно при большом